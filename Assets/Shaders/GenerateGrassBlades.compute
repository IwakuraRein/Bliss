#pragma kernel CSMain

#include "includes/GrassRenderProperty.hlsl"
#include "includes/Terrain.hlsl"

RWStructuredBuffer<GrassRenderProperty> _Properties;
//float4x4 _ScaleMat;
//float4x4 _RotMat;
float2 _GridOrigin;
float _GridSize;
int _ChunkWidth;
int _PropertiesStartIdx;

//float3 _Gravity;
//float3 _ColliderPos;
//float3 _ColliderRadius;

float4x4 RotateY(float rad)
{
    float c = cos(rad);
    float s = sin(rad);

    return float4x4(
        c, 0, s, 0,
        0, 1, 0, 0,
        -s, 0, c, 0,
        0, 0, 0, 1
        );
}
float4x4 Translation(float3 translation)
{
    float c = cos(translation);
    float s = sin(translation);

    return float4x4 (
        1, 0, 0, translation.x,
        0, 1, 0, translation.y,
        0, 0, 1, translation.z,
        0, 0, 0, 1);
}

// We used to just be able to use (1, 1, 1) threads for whatever population (not sure the old limit), but a Unity update
// imposed a thread limit of 65535.  Now, to render populations above that, we need to be more granular with our threads.
[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _ChunkWidth * _ChunkWidth) return;
    int X = id.x % _ChunkWidth;
    int Y = id.x / _ChunkWidth;
    
    float dx = hash(float(id.x)) * 2.0 - 1.0;
    float dy = hash(dx) * 2.0 - 1.0;

    dx += X; dy += Y;

    float2 pos = float2(_GridOrigin.x + _GridSize * dx, _GridOrigin.y + _GridSize * dy);

    float4x4 rotMat = RotateY(hash(dy) * 6.28318531);
    float4 right = mul(rotMat, float4(1, 0, 0, 0));
    right.xyz = normalize(right.xyz);

    _Properties[id.x + _PropertiesStartIdx].v0 = float4(pos.x, GetHeight(pos), pos.y, 1);
    _Properties[id.x + _PropertiesStartIdx].right = right;

}