#pragma kernel CSMain

#include "includes/GrassRenderProperty.hlsl"
#include "includes/Terrain.hlsl"
#include "includes/FBM.hlsl"

RWStructuredBuffer<GrassRenderProperty> _Properties;
//float4x4 _ScaleMat;
//float4x4 _RotMat;
float2 _GridOrigin;
float _GridSize;
int _ChunkWidth;
int _PropertiesStartIdx;

float _DeltaTime;
float _Time;
float _WindFieldMovingSpeed;
float _WindFieldMagnitude;
float _GrassStiffness;

float3 _Gravity;
//float3 _ColliderPos;
//float3 _ColliderRadius;

float4x4 RotateY(float rad)
{
    float c = cos(rad);
    float s = sin(rad);

    return float4x4(
        c, 0, s, 0,
        0, 1, 0, 0,
        -s, 0, c, 0,
        0, 0, 0, 1
        );
}
float4x4 Translation(float3 translation)
{
    float c = cos(translation);
    float s = sin(translation);

    return float4x4 (
        1, 0, 0, translation.x,
        0, 1, 0, translation.y,
        0, 0, 1, translation.z,
        0, 0, 0, 1);
}

float2 WindField(float2 pos)
{
    pos += _Time * _WindFieldMovingSpeed;
    float2 ret;
    ret.x = perlinNoise(pos * 800.0, 3);
    ret.y = perlinNoise(-pos * 800.0, 3);
    return normalize(ret) * _WindFieldMagnitude;
}

// We used to just be able to use (1, 1, 1) threads for whatever population (not sure the old limit), but a Unity update
// imposed a thread limit of 65535.  Now, to render populations above that, we need to be more granular with our threads.
[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _ChunkWidth * _ChunkWidth) return;
    int X = id.x % _ChunkWidth;
    int Y = id.x / _ChunkWidth;

    GrassRenderProperty prop = _Properties[id.x + _PropertiesStartIdx];
    float3 v2orig = prop.v1andv2.yzw;
    v2orig.y *= _GrassHeight;
    v2orig.xz *= _GrassWidth;

    // compute v0
    float dx = hash(float(id.x)) * 2.0 - 1.0;
    float dy = hash(dx) * 2.0 - 1.0;
    dx += X; dy += Y;
    float2 v0 = float2(_GridOrigin.x + _GridSize * dx, _GridOrigin.y + _GridSize * dy);

    // compute right dir
    float4x4 rotMat = RotateY(hash(dy) * 6.28318531);
    float4 right = mul(rotMat, float4(1, 0, 0, 0));
    right.xyz = normalize(right.xyz);

    // update v2 and v1
    float2 wind = WindField(v0);
    float3 force = float3(wind.x + _Gravity.x, _Gravity.y, _Gravity.z + wind.y);


    // write the result
    prop.v0 = float4(v0.x, GetHeight(v0), v0.y, 1);
    prop.right = right;
    _Properties[id.x + _PropertiesStartIdx] = prop;
}